---
title: "MSD 2019 Final Project"
subtitle: "A replication and extension of Housing, Health, and Happiness by Matias D. Cattaneo, Sebastian Galiani, Paul J. Gertler, Sebastian Martinez, and Roccio Titiunik, American Economic Journal: Economic Policy 2009"
author: "Nancy Thomas (nkt2111), Patrick Alrassy (pa2492), Brigid Lynch (bml2133)"
date: '`r Sys.time()`'
output:
  pdf_document:
    toc: yes
    toc_depth: 3
---



```{r setup, include=FALSE}
library(here)
library(scales)
library(modelr)
library(tidyverse)
library(haven)
library(broom)
library(estimatr)
theme_set(theme_bw())
knitr::opts_chunk$set(echo = TRUE)
```

# Import Data

Read in the two data files used for replication of the main results. The houshold dataset has information at the houshold level and includes data from both the 2000 Mexican Census and the 2005 Survey. The individual dataset has information at the individual level and includes data from the 2005 Survey.

```{r read-data}
household_dat <- read_dta(file = "PisoFirme_AEJPol-20070024_household.dta")
individual_dat <- read_dta(file = "PisoFirme_AEJPol-20070024_individual.dta")
```

Divides the data into treatment and control groups.

```{r divide-treatment-control}
household_treatment <- household_dat %>% filter(dpisofirme == 1)
household_control <- household_dat %>% filter(dpisofirme == 0)
individual_treatment <- individual_dat %>% filter(dpisofirme == 1)
individual_control <- individual_dat %>% filter(dpisofirme == 0)
```

# Model 1: no controls
Here, we fit linear models, varying the dependent variable and extracting the correlation coefficient as well as both the clustered and non-clustered standard errors.
```{r model-1}
# function for individual data set
model_1_i <- function(dependent,cluster=T) {
  data_updated<-individual_dat[!is.na(dependent),]
  dependent_updated <- dependent[!is.na(dependent)]
  if(cluster==T){
  return(tidy(lm_robust(dependent_updated ~ dpisofirme,data_updated,clusters=idcluster,return_vcov = T)))}
  else{
    return(tidy(lm_robust(dependent_updated ~ dpisofirme,data_updated)))
  }
}

# function for household data set
 model_1_hh <- function(dependent,cluster=T) {
  data_updated<-household_dat[!is.na(dependent),]
  dependent_updated <- dependent[!is.na(dependent)]
  if(cluster==T){
  return(tidy(lm_robust(dependent_updated ~ dpisofirme,data_updated,clusters=idcluster)))}
  else{
    return(tidy(lm_robust(dependent_updated ~ dpisofirme,data_updated)))
  }
 }
 
 #coefficient:  $estimate[2] for standard error: $std.error[2] 
 #for non clustered std error make argument false:$std.error[2]
 
# caluclates coefficients for each dependent variable
model_1_coeff <- c(model_1_hh(household_dat$S_shcementfloor)$estimate[2],model_1_hh(household_dat$S_cementfloorkit)$estimate[2],model_1_hh(household_dat$S_cementfloordin)$estimate[2],model_1_hh(household_dat$S_cementfloorbat)$estimate[2],model_1_hh(household_dat$S_cementfloorbed)$estimate[2],model_1_i(individual_dat$S_parcount)$estimate[2],model_1_i(individual_dat$S_diarrhea)$estimate[2],model_1_i(individual_dat$S_anemia)$estimate[2],model_1_i(individual_dat$S_mccdts)$estimate[2],model_1_i(individual_dat$S_pbdypct)$estimate[2],model_1_i(individual_dat$S_haz)$estimate[2],model_1_i(individual_dat$S_whz)$estimate[2],model_1_hh(household_dat$S_satisfloor)$estimate[2],model_1_hh(household_dat$S_satishouse)$estimate[2],model_1_hh(household_dat$S_satislife)$estimate[2],model_1_hh(household_dat$S_cesds)$estimate[2],model_1_hh(household_dat$S_pss)$estimate[2])

# calculates clustered standard errors for each dependent variable
model_1_std_error_clustered<- c(model_1_hh(household_dat$S_shcementfloor)$std.error[2],model_1_hh(household_dat$S_cementfloorkit)$std.error[2],model_1_hh(household_dat$S_cementfloordin)$std.error[2],model_1_hh(household_dat$S_cementfloorbat)$std.error[2],model_1_hh(household_dat$S_cementfloorbed)$std.error[2],model_1_i(individual_dat$S_parcount)$std.error[2],model_1_i(individual_dat$S_diarrhea)$std.error[2],model_1_i(individual_dat$S_anemia)$std.error[2],model_1_i(individual_dat$S_mccdts)$std.error[2],model_1_i(individual_dat$S_pbdypct)$std.error[2],model_1_i(individual_dat$S_haz)$std.error[2],model_1_i(individual_dat$S_whz)$std.error[2],model_1_hh(household_dat$S_satisfloor)$std.error[2],model_1_hh(household_dat$S_satishouse)$std.error[2],model_1_hh(household_dat$S_satislife)$std.error[2],model_1_hh(household_dat$S_cesds)$std.error[2],model_1_hh(household_dat$S_pss)$std.error[2])

# calculates non-clusted standard errors for each dependent variable
model_1_std_error<- c(model_1_hh(household_dat$S_shcementfloor,cluster=F)$std.error[2],model_1_hh(household_dat$S_cementfloorkit,cluster=F)$std.error[2],model_1_hh(household_dat$S_cementfloordin,cluster=F)$std.error[2],model_1_hh(household_dat$S_cementfloorbat,cluster=F)$std.error[2],model_1_hh(household_dat$S_cementfloorbed,cluster=F)$std.error[2],model_1_i(individual_dat$S_parcount,cluster=F)$std.error[2],model_1_i(individual_dat$S_diarrhea,cluster=F)$std.error[2],model_1_i(individual_dat$S_anemia,cluster=F)$std.error[2],model_1_i(individual_dat$S_mccdts,cluster=F)$std.error[2],model_1_i(individual_dat$S_pbdypct,cluster=F)$std.error[2],model_1_i(individual_dat$S_haz,cluster=F)$std.error[2],model_1_i(individual_dat$S_whz,cluster=F)$std.error[2],model_1_hh(household_dat$S_satisfloor,cluster=F)$std.error[2],model_1_hh(household_dat$S_satishouse,cluster=F)$std.error[2],model_1_hh(household_dat$S_satislife,cluster=F)$std.error[2],model_1_hh(household_dat$S_cesds,cluster=F)$std.error[2],model_1_hh(household_dat$S_pss,cluster=F)$std.error[2])

variables <- c("share_cement_floors", "kitchen", "dining_room", "bathroom", "bedroom", "parasite","diarrhea","anemia","MacArther","Peabody","height","weight","Sat_floor","Sat_House","Sat_life","Depression","Stress")

Model_1 <- data.frame(var = variables,coeff_1 = model_1_coeff,sce = model_1_std_error_clustered,sc=model_1_std_error)
```

# Model 2: age, demographic, and health-habit controls
Here, we fit linear models with age, demographic, and healh-habit controls, varying the dependent variable and extracting the correlation coefficient as well as both the clustered and non-clustered standard errors.
```{r model-2}
# control variables, set na to 0
individual_dat$S_HHpeople[is.na(individual_dat$S_HHpeople)]<- 0
individual_dat$S_rooms[is.na(individual_dat$S_rooms)]<- 0
individual_dat$S_age[is.na(individual_dat$S_age)]<- 0
individual_dat$S_gender[is.na(individual_dat$S_gender)]<- 0
individual_dat$S_childma[is.na(individual_dat$S_childma)]<- 0
individual_dat$S_childmaage[is.na(individual_dat$S_childmaage)]<- 0
individual_dat$S_childmaeduc[is.na(individual_dat$S_childmaeduc)]<- 0
individual_dat$S_childpa[is.na(individual_dat$S_childpa)]<- 0
individual_dat$S_childpaage[is.na(individual_dat$S_childpaage)]<- 0
individual_dat$S_childpaeduc[is.na(individual_dat$S_childpaeduc)]<- 0
individual_dat$S_waterland[is.na(individual_dat$S_waterland)]<- 0
individual_dat$S_waterhouse[is.na(individual_dat$S_waterhouse)]<- 0
individual_dat$S_electricity[is.na(individual_dat$S_electricity)]<- 0
individual_dat$S_hasanimals[is.na(individual_dat$S_hasanimals)]<- 0
individual_dat$S_animalsinside[is.na(individual_dat$S_animalsinside)]<- 0
individual_dat$S_garbage[is.na(individual_dat$S_garbage)]<- 0
individual_dat$S_washhands[is.na(individual_dat$S_washhands)]<- 0

# function for individual data set
model_2_i <- function(dependent,cluster=T) {
  # removes entries with na values
  data_updated<-individual_dat%>%filter(!is.na(dependent) & !is.na(individual_dat$idcluster))
  # control variables
  x1<- data_updated$S_HHpeople
  x2<-data_updated$S_rooms
  x3<-data_updated$S_age
  x4<-data_updated$S_gender
  x5<-data_updated$S_childma
  x6<-data_updated$S_childmaage
  x7<-data_updated$S_childmaeduc
  x8<-data_updated$S_childpa
  x9<-data_updated$S_childpaage
  x10<-data_updated$S_childpaeduc
  x11<-data_updated$S_waterland
  x12<-data_updated$S_waterhouse
  x13<-data_updated$S_electricity
  x14<-data_updated$S_hasanimals
  x15<-data_updated$S_animalsinside
  x16<-data_updated$S_garbage
  x17<-data_updated$S_washhands
  x18<- data_updated$dpisofirme
  updated_dependent<- dependent[!is.na(dependent)& !is.na(individual_dat$idcluster)]
  if(cluster==T)
  {
    return(tidy(lm_robust(updated_dependent ~ x18 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17,data_updated,clusters=idcluster)))
  }else{
    return(tidy(lm_robust(updated_dependent ~ x18 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17,data_updated)))
  }
}

# control variables, set na to 0
household_dat$S_HHpeople[is.na(household_dat$S_HHpeople)]<-0
household_dat$S_headage[is.na(household_dat$S_headage)]<-0
household_dat$S_spouseage[is.na(household_dat$S_spouseage)]<-0
household_dat$S_headeduc[is.na(household_dat$S_headeduc)]<-0
household_dat$S_spouseeduc[is.na(household_dat$S_spouseeduc)]<-0
household_dat$S_dem1[is.na(household_dat$S_dem1)]<-0
household_dat$S_dem2[is.na(household_dat$S_dem2)] <-0
household_dat$S_dem3[is.na(household_dat$S_dem3)]<-0
household_dat$S_dem4[is.na(household_dat$S_dem4)] <-0
household_dat$S_dem5[is.na(household_dat$S_dem5)]<-0
household_dat$S_dem6[is.na(household_dat$S_dem6)]<-0
household_dat$S_dem7[is.na(household_dat$S_dem7)] <-0
household_dat$S_dem8[is.na(household_dat$S_dem8)]<-0
household_dat$S_waterland[is.na(household_dat$S_waterland)]<-0
household_dat$S_waterhouse[is.na(household_dat$S_waterhouse)]<-0
household_dat$S_electricity[is.na(household_dat$S_electricity)]<-0
household_dat$S_hasanimals[is.na(household_dat$S_hasanimals)]<-0
household_dat$S_animalsinside[is.na(household_dat$S_animalsinside)]<-0
household_dat$S_garbage[is.na(household_dat$S_garbage)]<-0
household_dat$S_washhands[is.na(household_dat$S_washhands)]<-0

# function for household data set
model_2_hh <- function(dependent,cluster=T) {
  # removes entries with na values
  data_updated<-household_dat%>%filter(!is.na(dependent)&!is.na(idcluster))
  # control variables
  x1<- data_updated$S_HHpeople
  x2<-data_updated$S_headage
  x3<-data_updated$S_spouseage
  x4<-data_updated$S_headeduc
  x5<-data_updated$S_spouseeduc
  x6<-data_updated$S_dem1
  x7<-data_updated$S_dem2
  x8<-data_updated$S_dem3
  x9<-data_updated$S_dem4
  x10<-data_updated$S_dem5
  x11<-data_updated$S_dem6
  x12<-data_updated$S_dem7
  x13<-data_updated$S_dem8
  x14<-data_updated$S_waterland
  x15<-data_updated$S_waterhouse
  x16<-data_updated$S_electricity
  x17<-data_updated$S_hasanimals
  x18<-data_updated$S_animalsinside
  x19<-data_updated$S_garbage
  x20<-data_updated$S_washhands
  x21<-data_updated$dpisofirme
  updated_dependent<- dependent[!is.na(dependent)& !is.na(household_dat$idcluster)]
  if(cluster==T)
  {
    return(tidy(lm_robust(updated_dependent ~ x21 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17+x18+x19+x20,data_updated,clusters=idcluster)))
  }else{
    return(tidy(lm_robust(updated_dependent ~ x21 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17+x18+x19+x20,data_updated,clusters=idcluster)))
  }
}

# caluclates coefficients for each dependent variable
model_2_coeff <- c(model_2_hh(household_dat$S_shcementfloor)$estimate[2],model_2_hh(household_dat$S_cementfloorkit)$estimate[2],model_2_hh(household_dat$S_cementfloordin)$estimate[2],model_2_hh(household_dat$S_cementfloorbat)$estimate[2],model_2_hh(household_dat$S_cementfloorbed)$estimate[2],model_2_i(individual_dat$S_parcount)$estimate[2],model_2_i(individual_dat$S_diarrhea)$estimate[2],model_2_i(individual_dat$S_anemia)$estimate[2],model_2_i(individual_dat$S_mccdts)$estimate[2],model_2_i(individual_dat$S_pbdypct)$estimate[2],model_2_i(individual_dat$S_haz)$estimate[2],model_2_i(individual_dat$S_whz)$estimate[2],model_2_hh(household_dat$S_satisfloor)$estimate[2],model_2_hh(household_dat$S_satishouse)$estimate[2],model_2_hh(household_dat$S_satislife)$estimate[2],model_2_hh(household_dat$S_cesds)$estimate[2],model_2_hh(household_dat$S_pss)$estimate[2])

# caluclates clustered standard errors for each dependent variable
model_2_std_error_clustered<- c(model_2_hh(household_dat$S_shcementfloor)$std.error[2],model_2_hh(household_dat$S_cementfloorkit)$std.error[2],model_2_hh(household_dat$S_cementfloordin)$std.error[2],model_2_hh(household_dat$S_cementfloorbat)$std.error[2],model_2_hh(household_dat$S_cementfloorbed)$std.error[2],model_2_i(individual_dat$S_parcount)$std.error[2],model_2_i(individual_dat$S_diarrhea)$std.error[2],model_2_i(individual_dat$S_anemia)$std.error[2],model_2_i(individual_dat$S_mccdts)$std.error[2],model_2_i(individual_dat$S_pbdypct)$std.error[2],model_2_i(individual_dat$S_haz)$std.error[2],model_2_i(individual_dat$S_whz)$std.error[2],model_2_hh(household_dat$S_satisfloor)$std.error[2],model_2_hh(household_dat$S_satishouse)$std.error[2],model_2_hh(household_dat$S_satislife)$std.error[2],model_2_hh(household_dat$S_cesds)$std.error[2],model_2_hh(household_dat$S_pss)$std.error[2])

# caluclates non-clustered standard errors for each dependent variable
model_2_std_error<- c(model_2_hh(household_dat$S_shcementfloor,cluster=F)$std.error[2],model_2_hh(household_dat$S_cementfloorkit,cluster=F)$std.error[2],model_2_hh(household_dat$S_cementfloordin,cluster=F)$std.error[2],model_2_hh(household_dat$S_cementfloorbat,cluster=F)$std.error[2],model_2_hh(household_dat$S_cementfloorbed,cluster=F)$std.error[2],model_2_i(individual_dat$S_parcount,cluster=F)$std.error[2],model_2_i(individual_dat$S_diarrhea,cluster=F)$std.error[2],model_2_i(individual_dat$S_anemia,cluster=F)$std.error[2],model_2_i(individual_dat$S_mccdts,cluster=F)$std.error[2],model_2_i(individual_dat$S_pbdypct,cluster=F)$std.error[2],model_2_i(individual_dat$S_haz,cluster=F)$std.error[2],model_2_i(individual_dat$S_whz,cluster=F)$std.error[2],model_2_hh(household_dat$S_satisfloor,cluster=F)$std.error[2],model_2_hh(household_dat$S_satishouse,cluster=F)$std.error[2],model_2_hh(household_dat$S_satislife,cluster=F)$std.error[2],model_2_hh(household_dat$S_cesds,cluster=F)$std.error[2],model_2_hh(household_dat$S_pss,cluster=F)$std.error[2])

Model_2 <- data.frame(var = variables,coeff_2 = model_2_coeff,sce = model_2_std_error_clustered,sc=model_2_std_error)
```

# Model 3: age, demographic, health-habit and public social programs controls
Here, we fit linear models with age, demographic, healh-habit, and public social programs controls, varying the dependent variable and extracting the correlation coefficient as well as both the clustered and non-clustered standard errors.
```{r model-3}
# additional control variables, set na to 0
individual_dat$S_cashtransfers[is.na(individual_dat$S_cashtransfers)]<- 0
individual_dat$S_milkprogram[is.na(individual_dat$S_milkprogram)]<- 0
individual_dat$S_foodprogram[is.na(individual_dat$S_foodprogram)]<- 0
individual_dat$S_seguropopular[is.na(individual_dat$S_seguropopular)]<- 0

# function for individual data set
model_3_i <- function(dependent,cluster=T) {
  # removes entries with na values
   data_updated<-individual_dat%>%filter(!is.na(dependent) & !is.na(individual_dat$idcluster))
   # control variables
   x1<- data_updated$S_HHpeople
   x2<-data_updated$S_rooms
   x3<-data_updated$S_age
   x4<-data_updated$S_gender
   x5<-data_updated$S_childma
   x6<-data_updated$S_childmaage
   x7<-data_updated$S_childmaeduc 
   x8<-data_updated$S_childpa
   x9<-data_updated$S_childpaage 
   x10<-data_updated$S_childpaeduc
   x11<-data_updated$S_waterland
   x12<-data_updated$S_waterhouse 
   x13<-data_updated$S_electricity
   x14<-data_updated$S_hasanimals
   x15<-data_updated$S_animalsinside
   x16<-data_updated$S_garbage
   x17<-data_updated$S_washhands
   x18<-data_updated$S_cashtransfers
   x19<-data_updated$S_milkprogram
   x20<-data_updated$S_foodprogram
   x21<-data_updated$S_seguropopular
   x22<- data_updated$dpisofirme
   updated_dependent<- dependent[!is.na(dependent)& !is.na(individual_dat$idcluster)]
  if(cluster==T)
  {
    return(tidy(lm_robust(updated_dependent ~ x22 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17+x18+x19+x20+x21+x22,data_updated,clusters=idcluster)))
  }else{
    return(tidy(lm_robust(updated_dependent ~ x22 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17+x18+x19+x20+x21+x22,data_updated)))
  }
}
  
# additional control variables, set na to 0
household_dat$S_cashtransfers[is.na(household_dat$S_cashtransfers)]<- 0
household_dat$S_milkprogram[is.na(household_dat$S_milkprogram)]<- 0
household_dat$S_foodprogram[is.na(household_dat$S_foodprogram)]<- 0
household_dat$S_seguropopular[is.na(household_dat$S_seguropopular)]<- 0

# function for household data set
model_3_hh <- function(dependent,cluster=T) {
  data_updated <- household_dat%>%filter(!is.na(dependent) & !is.na(household_dat$idcluster))
  x1<- data_updated$S_HHpeople
  x2<-data_updated$S_headage
  x3<-data_updated$S_spouseage
  x4<-data_updated$S_headeduc
  x5<-data_updated$S_spouseeduc
  x6<-data_updated$S_dem1
  x7<-data_updated$S_dem2 
  x8<-data_updated$S_dem3
  x9<-data_updated$S_dem4 
  x10<-data_updated$S_dem5
  x11<-data_updated$S_dem6
  x12<-data_updated$S_dem7 
  x13<-data_updated$S_dem8
  x14<-data_updated$S_waterland
  x15<-data_updated$S_waterhouse
  x16<-data_updated$S_electricity
  x17<-data_updated$S_hasanimals
  x18<-data_updated$S_animalsinside
  x19<-data_updated$S_garbage
  x20<-data_updated$S_washhands
  x21<- data_updated$dpisofirme
  x22<-data_updated$S_cashtransfers
  x23<-data_updated$S_milkprogram
  x24<-data_updated$S_foodprogram
  x25<-data_updated$S_seguropopular
  updated_dependent<- dependent[!is.na(dependent)& !is.na(household_dat$idcluster)]
  if(cluster==T)
  {
    return(tidy(lm_robust(updated_dependent ~ x21 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17+x18+x19+x20+x22+x23+x24+x25,data_updated,clusters=idcluster)))
  }else{
    return(tidy(lm_robust(updated_dependent ~ x21 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17+x18+x19+x20+x22+x23+x24+x25,data_updated)))
  }
}
  
# caluclates coefficients for each dependent variable
model_3_coeff <- c(model_3_hh(household_dat$S_shcementfloor)$estimate[2],model_3_hh(household_dat$S_cementfloorkit)$estimate[2],model_3_hh(household_dat$S_cementfloordin)$estimate[2],model_3_hh(household_dat$S_cementfloorbat)$estimate[2],model_3_hh(household_dat$S_cementfloorbed)$estimate[2],model_3_i(individual_dat$S_parcount)$estimate[2],model_3_i(individual_dat$S_diarrhea)$estimate[2],model_3_i(individual_dat$S_anemia)$estimate[2],model_3_i(individual_dat$S_mccdts)$estimate[2],model_3_i(individual_dat$S_pbdypct)$estimate[2],model_3_i(individual_dat$S_haz)$estimate[2],model_3_i(individual_dat$S_whz)$estimate[2],model_3_hh(household_dat$S_satisfloor)$estimate[2],model_3_hh(household_dat$S_satishouse)$estimate[2],model_3_hh(household_dat$S_satislife)$estimate[2],model_3_hh(household_dat$S_cesds)$estimate[2],model_3_hh(household_dat$S_pss)$estimate[2])

# caluclates clustered standard errors for each dependent variable
model_3_std_error_clustered<- c(model_3_hh(household_dat$S_shcementfloor)$std.error[2],model_3_hh(household_dat$S_cementfloorkit)$std.error[2],model_3_hh(household_dat$S_cementfloordin)$std.error[2],model_3_hh(household_dat$S_cementfloorbat)$std.error[2],model_3_hh(household_dat$S_cementfloorbed)$std.error[2],model_3_i(individual_dat$S_parcount)$std.error[2],model_3_i(individual_dat$S_diarrhea)$std.error[2],model_3_i(individual_dat$S_anemia)$std.error[2],model_3_i(individual_dat$S_mccdts)$std.error[2],model_3_i(individual_dat$S_pbdypct)$std.error[2],model_3_i(individual_dat$S_haz)$std.error[2],model_3_i(individual_dat$S_whz)$std.error[2],model_3_hh(household_dat$S_satisfloor)$std.error[2],model_3_hh(household_dat$S_satishouse)$std.error[2],model_3_hh(household_dat$S_satislife)$std.error[2],model_3_hh(household_dat$S_cesds)$std.error[2],model_3_hh(household_dat$S_pss)$std.error[2])

# caluclates non-clustered standard errors for each dependent variable
model_3_std_error<- c(model_3_hh(household_dat$S_shcementfloor,cluster=F)$std.error[2],model_3_hh(household_dat$S_cementfloorkit,cluster=F)$std.error[2],model_3_hh(household_dat$S_cementfloordin,cluster=F)$std.error[2],model_3_hh(household_dat$S_cementfloorbat,cluster=F)$std.error[2],model_3_hh(household_dat$S_cementfloorbed,cluster=F)$std.error[2],model_3_i(individual_dat$S_parcount,cluster=F)$std.error[2],model_3_i(individual_dat$S_diarrhea,cluster=F)$std.error[2],model_3_i(individual_dat$S_anemia,cluster=F)$std.error[2],model_3_i(individual_dat$S_mccdts,cluster=F)$std.error[2],model_3_i(individual_dat$S_pbdypct,cluster=F)$std.error[2],model_3_i(individual_dat$S_haz,cluster=F)$std.error[2],model_3_i(individual_dat$S_whz,cluster=F)$std.error[2],model_3_hh(household_dat$S_satisfloor,cluster=F)$std.error[2],model_3_hh(household_dat$S_satishouse,cluster=F)$std.error[2],model_3_hh(household_dat$S_satislife,cluster=F)$std.error[2],model_3_hh(household_dat$S_cesds,cluster=F)$std.error[2],model_3_hh(household_dat$S_pss,cluster=F)$std.error[2])

Model_3 <- data.frame(var = variables,coeff_3 = model_3_coeff,sce = model_3_std_error_clustered,sc=model_3_std_error)
```

# Control Group Means and Standard Deviations
Calculates control group means and standard deviations, which are used as to understand the proportional impact of the dependent variable.
```{r control-mean-sd}
# function to calculate control mean
control_mean <- function(dependent) {
  updated_dependent<- dependent[!is.na(dependent)]
  return(mean(updated_dependent))
}

# function to calculate control standard deviation
control_sd <- function(dependent) {
  updated_dependent<- dependent[!is.na(dependent)]
  return(sd(updated_dependent))
}

# computes control mean for each dependent variable
control_mean <- c(control_mean(household_control$S_shcementfloor), control_mean(household_control$S_cementfloorkit), control_mean(household_control$S_cementfloordin), control_mean(household_control$S_cementfloorbat),control_mean(household_control$S_cementfloorbed),control_mean(individual_control$S_parcount),control_mean(individual_control$S_diarrhea),control_mean(individual_control$S_anemia),control_mean(individual_control$S_mccdts),control_mean(individual_control$S_pbdypct),control_mean(individual_control$S_haz),control_mean(individual_control$S_whz),control_mean(household_control$S_satisfloor),control_mean(household_control$S_satishouse),control_mean(household_control$S_satislife),control_mean(household_control$S_cesds),control_mean(household_control$S_pss))

# computes control standard deviation for each dependent variable
control_sd <- c(control_sd(household_control$S_shcementfloor), control_sd(household_control$S_cementfloorkit), control_sd(household_control$S_cementfloordin),control_sd(household_control$S_cementfloorbat),control_sd(household_control$S_cementfloorbed),control_sd(individual_control$S_parcount),control_sd(individual_control$S_diarrhea),control_sd(individual_control$S_anemia),control_sd(individual_control$S_mccdts),control_sd(individual_control$S_pbdypct),control_sd(individual_control$S_haz),control_sd(individual_control$S_whz),control_sd(household_control$S_satisfloor),control_sd(household_control$S_satishouse),control_sd(household_control$S_satislife),control_sd(household_control$S_cesds),control_sd(household_control$S_pss))

Mean_SD <- data.frame(var = variables, control_group_mean = control_mean, control_group_sd = control_sd)
```

```{r}
ggplot(Model_1,aes(x=var,y=coeff_1))+
  geom_pointrange(aes(ymin=coeff_1-sce,ymax=coeff_1+sce))+scale_x_discrete(labels=variables)+labs(y="Model 1 Linear Regression Coefficients",title="Model 1 Regression Coefficents for dependent variables")
ggplot(Model_2,aes(x=var,y=coeff_2))+
  geom_pointrange(aes(ymin=coeff_2-sce,ymax=coeff_2+sce))+scale_x_discrete(labels=variables)+labs(y="Model 2 Linear Regression Coefficients",title="Model 2 Regression Coefficents for dependent variables")
ggplot(Model_3,aes(x=var,y=coeff_3))+
  geom_pointrange(aes(ymin=coeff_3-sce,ymax=coeff_3+sce))+scale_x_discrete(labels=variables)+labs(y="Model 3 Linear Regression Coefficients",title="Model 3 Regression Coefficents for dependent variables")
```

# Compile Results into Tables 4, 5, 6
Organizes above results into Tables 4, 5, and 6 as in the paper.
```{r model-put-together}
Model <- Model_1 %>% left_join(Model_2, by = "var") %>% left_join(Model_3, by = "var") %>% left_join(Mean_SD, by = "var")

Table_4 <- Model %>% filter(var == "share_cement_floors" | var == "kitchen" | var == "dining_room" | var == "bathroom" | var == "bedroom") %>% select(var, control_group_mean, control_group_sd, coeff_1, coeff_2, coeff_3) %>% rename("Model_1" = coeff_1, "Model_2" = coeff_2, "Model_3" = coeff_3, "Dependent" = var)

Table_5 <- Model %>% filter(var == "parasite" | var == "diarrhea" | var == "anemia" | var == "MacArthur" | var == "Peabody" | var == "height" | var == "weight") %>% select(var, control_group_mean, control_group_sd, coeff_1, coeff_2, coeff_3) %>% rename("Model_1" = coeff_1, "Model_2" = coeff_2, "Model_3" = coeff_3, "Dependent" = var)

Table_6 <- Model %>% filter(var == "sat_floor" | var == "sat_House" | var == "sat_life" | var == "depression" | var == "stress") %>% select(var, control_group_mean, control_group_sd, coeff_1, coeff_2, coeff_3) %>% rename("Model_1" = coeff_1, "Model_2" = coeff_2, "Model_3" = coeff_3, "Dependent" = var)
```

# Logistic Regression
Here, we try to see if we can predict whether or not a house recieved the treatment based on the pre-treatment control variables. If we can predict whether or not the house received the treatment, we would have evidence to suggest that the treatment and control groups are not relatively equal, as claimed in the paper.
```{r logistic-regression}
household_dat$dpisofirme <- factor(household_dat$dpisofirme)

# selects out control variables
controlled_household <- household_dat %>% select(S_HHpeople, S_headage, S_spouseage, S_headeduc, S_spouseeduc, S_dem1, S_dem2, S_dem3, S_dem4, S_dem5, S_dem6, S_dem7, S_dem8, S_waterland, S_waterhouse, S_electricity, S_hasanimals, S_animalsinside, S_garbage, S_washhands, S_cashtransfers, S_milkprogram, S_foodprogram, S_seguropopular)

num_rows <- nrow(controlled_household)
frac_train <- 0.8
num_train <- floor(num_rows * frac_train)
ndx <- sample(1:num_rows, num_train, replace=F)
data_train <- controlled_household[ndx, ]
all_train <- household_dat[ndx, ]
data_test <- controlled_household[-ndx, ]
all_test <- household_dat[-ndx, ]
model <- glm(all_train$dpisofirme ~., data=data_train, family = "binomial")
df <- data.frame(actual = all_test$dpisofirme, log_odds = predict(model, data_test)) %>% mutate(pred = ifelse(log_odds > 0, '1', '0'))
table(actual = df$actual, predicted = df$pred)
# accuracy: fraction of correct classifications
df %>%summarize(acc = mean(pred == actual))
# precision: fraction of positive predictions that are actually true
df %>% filter(pred == '1') %>% summarize(prec = mean(actual == '1'))
# recall: fraction of true examples that we predicted to be positive
# aka true positive rate, sensitivity
df %>% filter(actual == '1') %>% summarize(recall = mean(pred == '1'))
# false positive rate: fraction of false examples that we predicted to be positive
df %>% filter(actual == '0') %>% summarize(fpr = mean(pred == '1'))
#probs <- data.frame(predict(model,data_test, type="raw"))
#plot_data <- data_test
#plot_data$probs <- predict(model, data_test, type="response")
#ggplot(plot_data, aes(x = probs)) + geom_histogram(binwidth = 0.01) + xlab('Predicted probability of Treatment') + ylab('Number of examples')
# plot calibration
#data.frame(predicted=plot_data$probs, actual=all_test$dpisofirme) %>% group_by(predicted=round(predicted*10)/10) %>% summarize(num=n(), actual=mean(actual == "1")) %>% ggplot(data=., aes(x=predicted, y=actual, size=num)) + geom_point() + geom_abline(linetype=2) + scale_x_continuous(labels=percent, lim=c(0,1)) + scale_y_continuous(labels=percent, lim=c(0,1)) + xlab('Predicted probability of Treatment') + ylab('Percent that are actually Treatment')
#pred <- prediction(plot_data$probs, yTest)
#perf_lr <- performance(pred, measure='tpr', x.measure='fpr')
#plot(perf_lr)
#performance(pred, 'auc')
```


# Logistic Regression
Here, we try to see if we can predict whether or not a house recieved the treatment based on the pre-treatment  variables. If we can predict whether or not the house received the treatment, we would have evidence to suggest that the treatment and control groups are not relatively equal, as claimed in the paper.
```{r Logistic-Regression}
set.seed(42)

household_dat$dpisofirme <- factor(household_dat$dpisofirme)

# selects pre-treatment variables
controlled_household <- household_dat %>%group_by(idcluster)%>%select(dpisofirme,C_blocksdirtfloor,C_HHdirtfloor,C_child05,C_households,C_people,C_rooms,C_HHpersons,C_waterland,C_waterhouse,C_waterbath,C_gasheater,C_refrigerator,C_washing,C_telephone,C_vehicle,C_overcrowding,C_poverty,C_illiterate,C_headeduc,C_dropouts515,C_employment,C_earnincome)%>%ungroup()%>%distinct()%>%select(-idcluster)

# separates training and test data
num_folds <- 5
num_rows <- nrow(controlled_household)
frac_train <- 0.8
num_train <- floor(num_rows * frac_train)
ndx <- sample(1:num_rows, num_train, replace=F)
classify<- controlled_household[ndx, ] %>%
  mutate(fold = (row_number() %% num_folds) + 1)
  # do 5-fold cross-validation within each value of 
accuracy<-c()
topterm<-c()
bottomterm<-c()
fpr<-c()
recall<-c()
precision<-c()
counter<-1
for (f in 1:num_folds) {
    # fit on the training data
    training <- filter(classify, fold != f)
    model <- glm(training$dpisofirme ~., data=training, family = "binomial")
    # evaluate on the validation data
    testing <- filter(classify, fold == f)
    
    df <- data.frame(actual = testing$dpisofirme, log_odds = predict(model, testing)) %>% mutate(pred = ifelse(log_odds > 0, '1', '0'))
table(actual = df$actual, predicted = df$pred)
# accuracy: fraction of correct classifications
acc<-df %>%summarize(acc = mean(pred == actual,na.rm=T))
accuracy[counter]<-acc[1]
prec<-df %>% filter(pred == '1') %>% summarize(prec = mean(actual == '1',na.rm=T))
precision[counter]<-prec[1]
rec<-df %>% filter(actual == '1') %>% summarize(recall = mean(pred == '1',na.rm=T))
recall[counter]<-rec[1]
fp<-df %>% filter(actual == '0') %>% summarize(fpr = mean(pred == '1',na.rm=T))
fpr[counter]<-fp[1]
modeldf<-tidy(model)
top<-modeldf%>%arrange(desc(estimate))%>%select(term)
bottom<-modeldf%>%arrange(estimate)%>%select(term)
topterm[counter]<-top[1,1]
bottomterm[counter]<-bottom[1,1]
counter<-counter+1
}  
mean(as.numeric(accuracy))
mean(as.numeric(recall))
mean(as.numeric(precision))
mean(as.numeric(fpr))
```

```{r}
supp.labs <- c("No Pisofirme", "Pisofirme")
names(supp.labs) <- c(0, 1)
ggplot(household_dat)+geom_histogram(aes(x=C_waterland))+facet_grid(~dpisofirme,labeller=labeller(dpisofirme=supp.labs))
ggplot(household_dat)+geom_histogram(aes(x=C_illiterate))+facet_grid(~dpisofirme,labeller=labeller(dpisofirme=supp.labs))
ggplot(household_dat)+geom_histogram(aes(x=C_refrigerator))+facet_grid(~dpisofirme,labeller=labeller(dpisofirme=supp.labs))
ggplot(household_dat)+geom_histogram(aes(x=C_HHdirtfloor))+facet_grid(~dpisofirme,labeller=labeller(dpisofirme=supp.labs))
```

# R Squared
Here, we compute r squared for each dependent variable. This is the amount of change in the dependent variable that can be explained by the independent variable. We calculate this for each model.
```{r r-sq-fct}
# function for model 1, individual data set
model_1_i_rsq <- function(dependent) {
  dummy_i <- individual_dat$dpisofirme[!is.na(dependent)]
  dependent_updated <- dependent[!is.na(dependent)]
  return(summary(lm(dependent_updated ~ dummy_i))$r.squared)
}

# function for model 1, household data set
model_1_hh_rsq <- function(dependent) {
  dummy_hh <- household_dat$dpisofirme[!is.na(dependent)]
  dependent_updated <- dependent[!is.na(dependent)]
  return(summary(lm(dependent_updated ~ dummy_hh ))$r.squared)
}

# function for model 2, individual data set
model_2_i_rsq <- function(dependent) {
  # control variables
  x1<- individual_dat$S_HHpeople[!is.na(dependent)]
  x2<-individual_dat$S_rooms[!is.na(dependent)]
  x3<-individual_dat$S_age[!is.na(dependent)]
  x4<-individual_dat$S_gender[!is.na(dependent)]
  x5<-individual_dat$S_childma[!is.na(dependent)]
  x6<-individual_dat$S_childmaage[!is.na(dependent)]
  x7<-individual_dat$S_childmaeduc[!is.na(dependent)] 
  x8<-individual_dat$S_childpa[!is.na(dependent)]
  x9<-individual_dat$S_childpaage[!is.na(dependent)] 
  x10<-individual_dat$S_childpaeduc[!is.na(dependent)]
  x11<-individual_dat$S_waterland[!is.na(dependent)]
  x12<-individual_dat$S_waterhouse[!is.na(dependent)] 
  x13<-individual_dat$S_electricity[!is.na(dependent)]
  x14<-individual_dat$S_hasanimals[!is.na(dependent)]
  x15<-individual_dat$S_animalsinside[!is.na(dependent)]
  x16<-individual_dat$S_garbage[!is.na(dependent)]
  x17<-individual_dat$S_washhands[!is.na(dependent)]
  x18<- individual_dat$dpisofirme[!is.na(dependent)]
  updated_dependent<- dependent[!is.na(dependent)]
  return(summary(lm( updated_dependent ~ x18 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17))$r.squared)
}

# function for model 2, household data set
model_2_hh_sq <- function(dependent) {
  # control variables
  x1<- household_dat$S_HHpeople[!is.na(dependent)]
  x2<-household_dat$S_headage[!is.na(dependent)]
  x3<-household_dat$S_spouseage[!is.na(dependent)]
  x4<-household_dat$S_headeduc[!is.na(dependent)]
  x5<-household_dat$S_spouseeduc[!is.na(dependent)]
  x6<-household_dat$S_dem1[!is.na(dependent)]
  x7<-household_dat$S_dem2[!is.na(dependent)] 
  x8<-household_dat$S_dem3[!is.na(dependent)]
  x9<-household_dat$S_dem4[!is.na(dependent)] 
  x10<-household_dat$S_dem5[!is.na(dependent)]
  x11<-household_dat$S_dem6[!is.na(dependent)]
  x12<-household_dat$S_dem7[!is.na(dependent)] 
  x13<-household_dat$S_dem8[!is.na(dependent)]
  x14<-household_dat$S_waterland[!is.na(dependent)]
  x15<-household_dat$S_waterhouse[!is.na(dependent)]
  x16<-household_dat$S_electricity[!is.na(dependent)]
  x17<-household_dat$S_hasanimals[!is.na(dependent)]
  x18<-household_dat$S_animalsinside[!is.na(dependent)]
  x19<-household_dat$S_garbage[!is.na(dependent)]
  x20<-household_dat$S_washhands[!is.na(dependent)]
  x21<- household_dat$dpisofirme[!is.na(dependent)]
  updated_dependent<- dependent[!is.na(dependent)]
  return(summary(lm(updated_dependent ~ x21 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17+ x18 + x19+ x20))$r.squared)
}

# function for model 3, individual data set
model_3_i_rsq <- function(dependent) {
  # control varibales
  x1<- individual_dat$S_HHpeople[!is.na(dependent)]
  x2<-individual_dat$S_rooms[!is.na(dependent)]
  x3<-individual_dat$S_age[!is.na(dependent)]
  x4<-individual_dat$S_gender[!is.na(dependent)]
  x5<-individual_dat$S_childma[!is.na(dependent)]
  x6<-individual_dat$S_childmaage[!is.na(dependent)]
  x7<-individual_dat$S_childmaeduc[!is.na(dependent)] 
  x8<-individual_dat$S_childpa[!is.na(dependent)]
  x9<-individual_dat$S_childpaage[!is.na(dependent)] 
  x10<-individual_dat$S_childpaeduc[!is.na(dependent)]
  x11<-individual_dat$S_waterland[!is.na(dependent)]
  x12<-individual_dat$S_waterhouse[!is.na(dependent)] 
  x13<-individual_dat$S_electricity[!is.na(dependent)]
  x14<-individual_dat$S_hasanimals[!is.na(dependent)]
  x15<-individual_dat$S_animalsinside[!is.na(dependent)]
  x16<-individual_dat$S_garbage[!is.na(dependent)]
  x17<-individual_dat$S_washhands[!is.na(dependent)]
  x18<-individual_dat$S_cashtransfers[!is.na(dependent)]
  x19<-individual_dat$S_milkprogram[!is.na(dependent)]
  x20<-individual_dat$S_foodprogram[!is.na(dependent)]
  x21<-individual_dat$S_seguropopular[!is.na(dependent)]
  x22<- individual_dat$dpisofirme[!is.na(dependent)]
  updated_dependent<- dependent[!is.na(dependent)]
  return(summary(lm( updated_dependent ~ x22 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17+ x18+x19 +x20+x22 ))$r.squared)
}

# function for model 3, household data set
model_3_hh_rsq <- function(dependent) {
  # control variables
  x1<- household_dat$S_HHpeople[!is.na(dependent)]
  x2<-household_dat$S_headage[!is.na(dependent)]
  x3<-household_dat$S_spouseage[!is.na(dependent)]
  x4<-household_dat$S_headeduc[!is.na(dependent)]
  x5<-household_dat$S_spouseeduc[!is.na(dependent)]
  x6<-household_dat$S_dem1[!is.na(dependent)]
  x7<-household_dat$S_dem2[!is.na(dependent)] 
  x8<-household_dat$S_dem3[!is.na(dependent)]
  x9<-household_dat$S_dem4[!is.na(dependent)] 
  x10<-household_dat$S_dem5[!is.na(dependent)]
  x11<-household_dat$S_dem6[!is.na(dependent)]
  x12<-household_dat$S_dem7[!is.na(dependent)] 
  x13<-household_dat$S_dem8[!is.na(dependent)]
  x14<-household_dat$S_waterland[!is.na(dependent)]
  x15<-household_dat$S_waterhouse[!is.na(dependent)]
  x16<-household_dat$S_electricity[!is.na(dependent)]
  x17<-household_dat$S_hasanimals[!is.na(dependent)]
  x18<-household_dat$S_animalsinside[!is.na(dependent)]
  x19<-household_dat$S_garbage[!is.na(dependent)]
  x20<-household_dat$S_washhands[!is.na(dependent)]
  x21<- household_dat$dpisofirme[!is.na(dependent)]
  x22<-household_dat$S_cashtransfers[!is.na(dependent)]
  x23<-household_dat$S_milkprogram[!is.na(dependent)]
  x24<-household_dat$S_foodprogram[!is.na(dependent)]
  x25<-household_dat$S_seguropopular[!is.na(dependent)]
  updated_dependent<- dependent[!is.na(dependent)]
  return(summary(lm(updated_dependent ~ x21 + x1 + x2 + x3  + x4+ x5+ x6+ x7+ x8+ x9+ x10+ x11+ x12+ x13+ x14+ x15+ x16+ x17+ x18 + x19+ x20 + x22 + x23 + x24+ x25 ))$r.squared)
}
```

```{r-sq-tables}
# r square coefficients for table 4
T4_rsq <- data.frame(dependent = c("share_cement_floors", "kitchen", "dining_room", "bedroom", "bathroom"))

T4_rsq$data <- list(c(household_dat$S_shcementfloor), c(household_dat$S_cementfloorkit), c(household_dat$S_cementfloordin), c(household_dat$S_cementfloorbed), c(household_dat$S_cementfloorbat))

T4_rsq <- T4_rsq %>% mutate(r_sq_m1 = map(data, model_1_hh_rsq), r_sq_m2 = map(data, model_2_hh_sq), r_sq_m3 = map(data, model_3_hh_rsq)) %>% select(dependent, r_sq_m1, r_sq_m2, r_sq_m3)

# r squared coefficients for table 5
T5_rsq <- data.frame(dependent = c("parasite", "diarrhea", "anemia", "MacArthur", "Peabody", "height", "weight"))

T5_rsq$data <- list(c(individual_dat$S_parcount), c(individual_dat$S_diarrhea), c(individual_dat$S_anemia), c(individual_dat$S_mccdts), c(individual_dat$S_pbdypct), c(individual_dat$S_haz), c(individual_dat$S_whz))

T5_rsq <- T5_rsq %>% mutate(r_sq_m1 = map(data, model_1_i_rsq), r_sq_m2 = map(data, model_2_i_rsq), r_sq_m3 = map(data, model_3_i_rsq)) %>% select(dependent, r_sq_m1, r_sq_m2, r_sq_m3)

# r squared coefficients for table 6
T6_rsq <- data.frame(dependent = c("sat_floor", "sat_house", "sat_life", "depression", "stress"))

T6_rsq$data <- list(c(household_dat$S_satisfloor), c(household_dat$S_satishouse), c(household_dat$S_satislife), c(household_dat$S_cesds), c(household_dat$S_pss))

T6_rsq <- T6_rsq %>% mutate(r_sq_m1 = map(data, model_1_hh_rsq), r_sq_m2 = map(data, model_2_hh_sq), r_sq_m3 = map(data, model_3_hh_rsq)) %>% select(dependent, r_sq_m1, r_sq_m2, r_sq_m3)

```
# R Squared Plots
Here, we try to see if there is any trend between the coefficients for the dependents for each model and the r squared values.

```{r r-sq-plots}
T4_2 <- Table_4 %>% full_join(T4_rsq, by = "Dependent")
T5_2 <- Table_5 %>% full_join(T5_rsq, by = "Dependent")
T6_2 <- Table_6 %>% full_join(T6_rsq, by = "Dependent")

T_Tot <- T4_2 %>% full_join(T5_2) %>% full_join(T6_2)

ggplot(data = T_Tot) + geom_point(mapping = aes(x = Model_1, y = r_sq_m1)) + xlab("Model 1 Coefficients") + ylab("Model 1 R Squared") + ggtitle("Model 1")
ggplot(data = T_Tot) + geom_point(mapping = aes(x = Model_2, y = r_sq_m2)) + xlab("Model 2 Coefficients") + ylab("Model 2 R Squared") + ggtitle("Model 2")
ggplot(data = T_Tot) + geom_point(mapping = aes(x = Model_3, y = r_sq_m3)) + xlab("Model 3 Coefficients") + ylab("Model 3 R Squared") + ggtitle("Model 3")
```

The following is a list of all packages used to generate these results. (Leave at very end of file.)

```{r}
sessionInfo()
```
